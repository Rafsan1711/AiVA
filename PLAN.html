chatgpt এর লেখা=
(প্লাগইন বৈশিষ্ট্য এবং কার্যপদ্ধতি বিবরণ

প্লাগইন সারসংক্ষেপ

আমাদের চ্যাটবট সিস্টেমে একটি নতুন প্লাগইন যুক্ত করা হয়েছে যা সোর্স কোড পরিচালনার জন্য ডিজাইন করা।

এই প্লাগইনটি একটি কার্ড-ভিত্তিক ইন্টারফেস ব্যবহার করবে, যেখানে কোড ফাইল তৈরি, সম্পাদন, এবং সংশোধন করা সম্ভব হবে।

প্লাগইন সক্রিয় করার পর প্লাগইন তালিকায় একটি নতুন আইকন বা এন্ট্রি দেখা যাবে এবং ক্লিক করলে একটি চ্যাট উইন্ডো খুলবে।

উল্লেখযোগ্যভাবে, এই প্লাগইনটির জন্য শুধুমাত্র একটি মাত্র চ্যাট খোলা যাবে; বারবার নতুন চ্যাট তৈরির চেষ্টা করলে পূর্বের একই চ্যাটে ফিরিয়ে নিয়ে যাওয়া হবে।

ফাইল নির্মাণ এবং সোর্স কোড কার্ড

চ্যাটের মূল কার্ডে একটি বোতাম থাকবে যেটির শিরোনাম “Create a new file +” (ফাইল তৈরি করুন +)।

যখন ব্যবহারকারী এই বোতামটি ক্লিক করবে, তখন কার্ডের মধ্যে পরিবর্তন হবে এবং দুইটি ইনপুট বক্স দেখাবে:

একটি ইনপুট বক্স ফাইলের নাম (যেমন: index.html) প্রবেশ করার জন্য।

আরেকটি ইনপুট বক্সে ঐ ফাইলে লিখিত কোড পেস্ট করে দেওয়া হবে।

উদাহরণস্বরূপ, ব্যবহারকারী যদি index.html নামে একটি ফাইল তৈরি করে এবং নীচের ইনপুট বক্সে HTML কোড পেস্ট করে, তখন নিচে “Create” এবং “Cancel” নামে দুটি বোতাম দেখাবে।

Create ক্লিক করলে সে ফাইল মূল কার্ডে একটি নতুন সাব-কার্ড আকারে প্রদর্শিত হবে, যেখানে ফাইলের নাম (যেমন index.html) দেখাবে, এবং ডান পাশে “Create a new file +” বোতানটি সরিয়ে অন্য সব ফাইলের পাশে থাকবে।

একাধিক ফাইল তৈরি করার অনুমতি থাকবে (যেমন HTML, CSS, JS, JSON ইত্যাদি ফাইল), এবং প্রতিটি ফাইলের জন্য একটি করে সাব-কার্ড তৈরি হবে।

প্রতিটি ফাইল কার্ডে ক্লিক করলে ঐ ফাইলের কোড সম্পাদনা এবং পরিবর্তন (commit changes) করা যাবে, যা প্রায় গিটহাবের রিপোজিটরির মতো আচরণ করবে।

সমস্ত সোর্স কোড ডেটা Firebase Realtime Database-এ সংরক্ষিত হবে। অর্থাৎ, ব্যবহারকারী কোড পরিবর্তন করলে তা ডাটাবেসে আপডেট হয়ে যাবে এবং পরবর্তীতে পুনরায় লোড বা প্রবেশ করলে সবশেষ কোডই দেখা যাবে।

ফিচার জেনারেশন এবং ব্যাখ্যা

messege input box এর উপরে একটি বোতাম থাকবে যার লেবেল “Generate feature with AI” (এআই-এর সাহায্যে ফিচার তৈরি)। এধরনের বাটন বিভিন্ন ai এ বিভিন্ন কাজ করে যেমন file input.

এই বোতাম ক্লিক করলে অথবা ব্যবহারকারী ইনপুট বক্সে কোনও ফিচারের ধারণা লিখলে এআই তার উপর ভিত্তি করে বাস্তবসম্মত একটি ফিচারের বর্ণনা জেনারেট করবে।

উদাহরণস্বরূপ, ইনপুট বক্সে ফিচার হিসেবে লেখা থাকতে পারে: “sign up/log in system upgrade”। এআইটি প্রথমে এই ফিচারটি পড়ে নিয়ে ব্যবহারকারীর উদ্দেশ্য বুঝতে চেষ্টা করবে।

তারপর এআই একটি সংক্ষিপ্ত ও স্পষ্ট বর্ণনা দেবে যে ফিচারটির মাধ্যমে কী কী অর্জন করা হবে, অর্থাৎ ব্যবহারকারীর কী কী দরকার বুঝতে পেরেছে।

এই বর্ণনার নিচে দুটি বোতাম থাকবে: “Satisfied” (সেটিস্ফাইড) এবং “Not satisfied” (নট স্যাটিস্ফাইড)।

Satisfied বোতাম ক্লিক করলে এআই কোড জেনারেশন প্রক্রিয়া শুরু করবে।

Not satisfied বোতাম ক্লিক করলে ব্যবহারকারী আরও ইনপুট প্রদান করতে পারবে অথবা অতিরিক্ত তথ্য যোগ করে এআইকে পুনরায় বুঝানোর সুযোগ দেবে।

কোড জেনারেশন এবং উপস্থাপনা

যখন ব্যবহারকারী Satisfied বোতামটি ক্লিক করে, তখন এআই সেই ফিচারের ভিত্তিতে কোড তৈরি করবে।

এআই-এর উত্তর একটি কার্ডে রঙিন (syntax-highlighted) কোড হিসেবে দেখাবে, যেমনটি চ্যাটজিপিটি বা অন্যান্য এআই চ্যাটে কোড ব্লক হিসাবে প্রদর্শন করে।

এই কোড কার্ডের উপরে একটি লেবেল থাকবে “Copy Code” বা অনুরূপ, যা কোডটি কপি করার সুযোগ দেবে।

কোড জেনারেশন সম্পন্ন হলে, ঐ বার্তার নিচে একটি “Debug” (ডিবাগ) বোতাম প্রদর্শিত হবে।

ডিবাগিং এবং সংশোধন

ব্যবহারকারী যখন “Debug” বোতামটি ক্লিক করবে, তখন এআই পুরনো কোড কার্ডটি আবার দেখাবে, কিন্তু এবার প্রতি লাইন আলাদা আলাদা হাইলাইট করে দেখাবে যেন ব্যবহারকারী মনে করে কোড ডিবাগ করা হচ্ছে।

এআই ঐ কোডটি পর্যালোচনা করে বলবে কোন অংশগুলো ঠিক আছে এবং কোন অংশে ত্রুটি (বাগ) থাকতে পারে।

এরপর এআই ব্যবহারকারীকে জিজ্ঞাসা করবে যে অবশিষ্ট সমস্যা (যা ঠিক হয়নি) ঠিক করে সম্পূর্ণ কোড আবার সরবরাহ করতে চায় কিনা।

ব্যবহারকারী যদি “হ্যাঁ” (Yes) বলে, তাহলে এআই সংশোধিত কোড দিয়ে আবার একটি কার্ড দেখাবে যা আসল কোড কার্ডের মতোই হবে কিন্তু বাগ সংশোধন করা থাকবে।

এই ফাইনাল কোডও পুনরায় ডিবাগের জন্য অনুরোধ করা যেতে পারে। উদাহরণস্বরূপ, ব্যবহারকারী যদি আবার ডিবাগ ক্লিক করে এবং এআই বলবে সব ঠিক আছে, তখন ডিবাগিং সম্পূর্ণ বলে নেওয়া হবে।

এরপর ব্যবহারকারী ঐ কোডটি নিয়ে পরীক্ষা করে দেখবে এবং ঠিক থাকলে পরবর্তী ধাপে যাবে।

পর্যায়ক্রমিক ধাপসমূহ (Workflow)

ফিচার জেনারেট করা: “Generate feature with AI” বোতাম ক্লিক অথবা ইনপুট ফিচার দিলে এআই সেই ফিচারটি পড়ে নেবে এবং আমাদের উদ্দেশ্য বোঝার চেষ্টা করবে।

বোঝাপড়া ব্যাখ্যা: এআই বিস্তারিতভাবে ব্যাখ্যা করবে যে সে কী কী বুঝেছে ফিচারের ব্যাপারে।

কোড প্রজন্ম: আমাদের “Satisfied” বোতাম ক্লিক করার পর এআই প্রয়োজনীয় কোড জেনারেট করে একটি কার্ডে প্রদর্শন করবে। কোডটি রঙিনভাবে দেখাবে এবং “Copy Code” বিকল্প থাকবে।

ডিবাগ ও ওভারভিউ: “Debug” বোতাম ক্লিক করার পর এআই কোডটি লাইনের ভিত্তিতে পরীক্ষা করে বলে কোন অংশ সঠিক এবং কোন অংশের ত্রুটি রয়েছে।

ত্রুটি সংশোধন: যদি কোনও বাগ পাওয়া যায়, এআই আমাদের অনুমোদনের পর সংশোধিত সম্পূর্ণ কোড আবার কার্ড আকারে প্রদান করবে।

উদাহরণ ও সিমুলেশন

ধরুন চ্যাটে আমি তিনটি ফাইল খুলি: index.html, server.js, এবং package.json। এই তিনটি ফাইলের কোড Firebase Realtime Database-এ সংরক্ষণ হয়ে থাকে।

আমি “Generate feature with AI” দিয়ে ইনপুট দিচ্ছি: “sign up/log in system upgrade”। এআই এই ফিচারটি পড়ে আমার উদ্দেশ্য সম্পর্কে একটি সারসংক্ষেপ দেয়।

আমি যদি প্রথমে “Not satisfied” দিয়ে অতিরিক্ত তথ্য দিই, তারপর “Satisfied” বাটনে ক্লিক করি, তখন এআই একটি কোড কার্ডে index.html-এর জন্য HTML কোড তৈরি করে দেখাবে।

আমি “Debug” বাটনে ক্লিক করলে এআই বলে index.html কোডের কোন কোন অংশ ঠিক আছে আর কোন অংশে সমস্যা আছে, এবং কি কি ঠিক করতে হবে।

যদি আমি হ্যাঁ বলি, তাহলে এআই ফাইনাল সংস্করণ index.html কোড দেয়। এরপর আমি আবার ডিবাগ বাটনে ক্লিক করে এআইকে চেক করতে বলি এবং এআই বলে সব ঠিক আছে।

এরপর আমি “next code” চাইলে এআই server.js এবং package.json এর কোড একই ধাপে পর্যায়ক্রমে প্রস্তুত করে দেখাবে।

সব কোড সম্পূর্ণ দেওয়ার পর চ্যাটের নীচে একটি বার্তা থাকবে: “Satisfied? (Yes/No)” বাটন সহ।

চূড়ান্ত কোড আপডেট এবং সেভিং

যদি আমি সর্বশেষে “Satisfied” দিয়ে নিশ্চিত করি, তাহলে সকল চ্যাটে থাকা মেসেজ (বিশেষ করে সোর্স কোড কার্ডের নিচের মেসেজগুলো) ডিলেট হয়ে যাবে।

তারপর প্রতিটি ফাইলের ফাইনাল কোড সোর্স কোড কার্ড-এ আপডেট হয়ে যাবে। অর্থাৎ, এখন দেখাবে যে প্রতিটি ফাইলের কনটেন্ট হলো শেষ পর্যায়ের ঠিক করা কোড।

যেহেতু কোডগুলি Firebase ডাটাবেসে সংরক্ষিত, সাইট বন্ধ করে আবার খোলার পরও তা পরিবর্তিত থাকবে।

ব্যবহারকারী চাইলে সোর্স কোড কার্ড থেকে কোড কপি করে নিজের GitHub রিপোজিটরিতে ব্যবহার করতে পারবে।

এরপরে একই চ্যাটে নতুন নতুন ফিচার নিয়ে আবার এই প্রক্রিয়া শুরু করা যায়, মানে একটি চক্র (Loop) এর মতো ফিচার → কোড → ডিবাগ → আপডেট কাজ করবে।

একক চ্যাট সীমাবদ্ধতা

এই প্লাগইনটিতে শুধুমাত্র একটি চ্যাট খোলা যাবে। অর্থাৎ, অন্য কোন নতুন চ্যাট খোলার চেষ্টা করলে তা পুরনো একই চ্যাটে নিয়ে আসবে।

উদাহরণস্বরূপ, একটি আলাদা মডিউল প্লাগইনে একাধিক চ্যাট থাকতে পারে, কিন্তু এই সোর্স কোড প্লাগইনে থাকবে না।

চ্যাট মুছার প্রক্রিয়া

যদি ব্যবহারকারী এই চ্যাটটি মুছতে চায়, একটি মডাল ডায়ালগ প্রদর্শিত হবে যা বলবে কি কি ডিলেট হবে (যেমন ফাইল এবং কোড) এবং একটি চেকবক্স থাকবে যাতে ইউজার নিশ্চিত করে যে তিনি মুছে ফেলতে চান।

ইউজার চেকবক্স সিলেক্ট করলে এবং কনফার্ম করলে চ্যাট এবং সংশ্লিষ্ট সমস্ত ডেটা মুছে যাবে।

আমার বোঝাপড়া

প্লাগইনটি একটি চ্যাটবট প্লাগইন, যেখানে ব্যবহারকারী নতুন ফাইল তৈরি, সম্পাদন ও কোড আপডেট করতে পারে একটি কার্ড-ভিত্তিক ইন্টারফেস ব্যবহার করে।

শুরুতে একটি “Create a new file +” বোতাম থেকে ফাইলের নাম ও কোড ইনপুট নিয়ে নতুন ফাইল তৈরি করা যায়। প্রতিটি তৈরি ফাইলের জন্য কার্ডে ফাইলের নাম দেখাবে এবং এর পাশে কোডের ডিবাগ, আপডেট ইত্যাদি অপশন থাকবে।

ফিচার জেনারেশন: ফিচারের বর্ণনা ইনপুট দিলে বা “Generate feature with AI” বোতাম ক্লিক করলে এআই সেই ফিচার বুঝে একটি সংক্ষিপ্ত ব্যাখ্যা দেয়। ব্যাখ্যার পর Satisfied বা Not satisfied বোতাম থেকে ব্যবহারকারী প্রয়োজনীয় পদক্ষেপ নেয়।

কোড জেনারেশন: যখন ফিচার সহ অনুমোদন দেয়া হয়, এআই ফিচারের ভিত্তিতে কোড তৈরি করে একটি কার্ডে দেখায়। কোডটি কোড-ব্লক আকারে রঙিন (syntax-highlighted) হবে এবং উপরে “Copy Code” অপশন থাকবে।

ডিবাগ ফেজ: কোড প্রদানের পর “Debug” বোতাম দিয়ে ব্যবহারকারী ডিবাগ শুরু করতে পারে। এআই কোডটি লাইন ধরে পরীক্ষা করে ঠিক ও ভুল অংশ চিহ্নিত করে বলে এবং প্রয়োজনের ক্ষেত্রে সংশোধিত কোড দেয়।

পরবর্তী ধাপ: সংশোধনী চক্রের পর চূড়ান্ত কোড সোর্স কার্ডে আপডেট করে নেওয়া হয়। কোড Firebase ডাটাবেসে সংরক্ষিত থাকে, তাই পুনরায় সাইটে ঢোকার পরও শেষ অবস্থা বজায় থাকে।

প্লাগইনটিতে শুধুমাত্র একটি চ্যাট থাকবে। এটি মুছে ফেললে চ্যাট সংক্রান্ত সমস্ত ডেটা মুছে যাবে এবং একটি নিশ্চিতকরণ মডাল দেখাবে কি কি মুছে যাবে।)
